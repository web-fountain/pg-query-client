<!-- 656a39c3-d2f5-4141-87b8-dba153312c46 2d4ac7f1-732c-4d38-b88c-6d50984a7fea -->
# DirectoryPanel Data Flow

## Summary

Implement SSR initial load for the QUERIES section’s children, then use client-side server actions for saves/renames/moves. Keep the tree’s two loaders but back them with one server function and a small client cache. Store tree in Redux for optimistic updates.

## Key Decisions

- Root `queries` is constant; do not fetch a root item.
- On first render (server), fetch children for `queries` and pass down.
- Keep both `dataLoader.getItem` and `getChildrenWithData`; back both with one server function returning `{ item, children }` and use a client cache.
- Minimal fields required by adapters: `id`, `kind` ('folder'|'query'), `name`.
- Manage optimistic updates in Redux: `nodes`, `childrenByParent`, `roots`.

## Implementation Steps

1) Create server function to fetch initial data

- New action `getQueriesTree()` returning `{ item, children }` with children sorted folder-first then name. The JWT has the tenant, opspace, and operator IDs, the Server can extract them to retrieve the query tree of the opspace.

2) Fetch in server layout and pass props

- In `src/app/opspace/[opspaceId]/queries/layout.tsx`, fetch children for `'queries'` and pass as `initialChildren` to a wrapper around `DirectoryPanel` (or directly to a client `SectionTreeClient`).

3) Caching

- Server: cache the initial “children for queries” with Cache Components or tagged fetch.
- Client: use Redux as the cache; dataLoader reads Redux first, fetches only if missing; server actions call updateTag to keep server caches coherent.

4) Redux QueriesTree (normalized - see similar records to follow style/pattern)

- `nodes: Record<id, { id, kind, name, parentId? }>`
- `childrenByParent: Record<parentId, id[]>`
- `roots: string[]` (contains `'queries'`).
- Selector to produce `{ id, data }[]` for any parent id to feed the tree or seed cache.

5) Save flow (optimistic)

- After `saveDataQueryThunk` success, dispatch `tree.addChild({ parentId: 'queries', node: { id, kind: 'query', name } })`.
- Optionally trigger a background refresh of `'queries'` children.

6) Rename/move flow

- Server actions return `{ parentId }` (rename) and `{ oldParentId, newParentId }` (move).
- Update Redux accordingly and refresh those parents in the tree.

7) Depth policy

- Keep UI guard (already implemented) and enforce on server. No payload changes needed.

## Minimal JSON Contracts

- Tree item (used by adapters):
```json
{ "id": "string", "kind": "folder|query", "name": "string" }
```

- Children with data (preferred loader):
```json
[
  { "id": "child-id", "data": { "id": "child-id", "kind": "query", "name": "report.sql" } }
]
```

- Optional combined result for single-call backend:
```json
{
  "item": { "id": "queries", "kind": "folder", "name": "QUERIES" },
  "children": [ { "id": "q1", "data": { "id": "q1", "kind": "query", "name": "revenue.sql" } } ]
}
```


## Small Examples

- Server wrapper fetch in layout (SSR first render)
```tsx
// app/opspace/[opspaceId]/queries/layout.tsx (server)
import DirectoryPanel from './[dataQueryId]/_components/DirectoryPanel';
import { getQueriesTree } from '@/actions/queries';

export default async function Layout({ children, params }) {
  const initialQueriesTree = await getQueriesTree();
  return (
    <DirectoryPanel collapsed={false} side="right" initialQueriesTree={initialQueriesTree} />
      {children}
    </DirectoryPanel>
  );
}
```

- Server cached fetch (SSR) with tags (works with updateTag/revalidateTag)
```ts
// _actions/queries.ts
'use server';

import { revalidateTag, updateTag } from 'next/cache';

const treeTag = (userId: string, parentId: string) => `tree:children:${userId}:${parentId}`;

export async function getQueriesTree() {
  // If you call a route/DB here, tag the fetch
  const res = await fetch(`${process.env.PG_QUERY_CLIENT_SERVER_URL}/queries/tree`, {
    next: { tags: ['queries-tree'] }
  });
  return await res.json(); // [{ id, data: { id, kind, name } }]
}

// In your server action that modifies the tree (too be implemented later):
export async function saveDataQueryAction(userId: string, payload: { name: string }) {
  // ...persist to DB...
  updateTag(treeTag(userId, 'queries')); // instant read-your-writes for SSR caches
  return { success: true, id: 'new-id' };
}
```

- Client dataLoader using Redux as cache 
```ts
// pseudo-code inside SectionTree Client
async function getChildrenWithData(parentId: string) {
  const fromRedux = selectChildrenWithData(store.getState(), parentId); // [{ id, data }]
  if (fromRedux?.length) return fromRedux;

  const rows = await saveOrFetchChildrenServerAction(parentId); // calls server; on success, dispatch into Redux
  store.dispatch(treeActions.setChildren({ parentId, rows }));
  return rows;
}

async function getItem(id: string) {
  const fromRedux = selectItem(store.getState(), id); // { id, kind, name } if present
  if (fromRedux) return fromRedux;
  const item = await fetchItemServerAction(id);
  store.dispatch(treeActions.upsertNode(item));
  return item;
}
```

- Redux slice shape and optimistic insert
```ts
// insert under QUERIES after save success
dispatch(tree.addChild({ parentId: 'queries', node: { id, kind: 'query', name } }));
```

- Selector returning children-with-data for the tree
```ts
const selectChildrenWithData = (state, parentId) => {
  const ids = state.tree.childrenByParent[parentId] || [];
  return ids.map(id => ({ id, data: state.tree.nodes[id] }));
};
```


## Additional Recommendations

- Server cache tags:
  - Use a stable key, e.g., `tree:children:{userId}:{parentId}`. Call `updateTag()` after create/rename/move; for move, update both old and new parent tags. See Next.js 16 caching APIs [link].
- Sorting: Ensure DB returns children folder-first, then name. With only files, sort by name for stable UX.
- Stable IDs: Prefer server-generated ids. If optimistic, either use a temporary id and reconcile, or await id before inserting to avoid flicker.
- Error handling: Add rollback path for optimistic insert/rename/move; surface a toast and re-fetch the affected parent.
- Multi-tenant security: Scope all queries by tenant/opspace/operator (use the OBO auth helper). Validate access on server actions.
- Depth rule: Enforce max depth on server (create/move) using subtree height; mirror the UI rule.
- Large folders: Consider pagination or chunked loading if a folder contains many items; add optional `hasMore` for future-proofing.
- Testing: Add reducer tests for the tree slice and server-action tag invalidation tests; integration test optimistic save.
- Hydration/virtualization: Seed client cache from SSR props to avoid initial fetch; measure the virtualizer after mount to prevent layout shift (already done).

[Next.js 16 – Improved Caching APIs](https://nextjs.org/blog/next-16#improved-caching-apis)

## Implementation

1) Redux: add QueriesTree record

- Create `src/redux/records/queriesTree/types.ts`
```ts
export type TreeNode = { id: string; kind: 'folder' | 'query'; name: string; parentId?: string };
export type ChildrenRow = { id: string; data: TreeNode };
export type QueriesTreeState = {
  nodes: Record<string, TreeNode>;
  childrenByParent: Record<string, string[]>;
  roots: string[];
};
```

- Create `src/redux/records/queriesTree/index.ts`
```ts
import type { PayloadAction } from '@reduxjs/toolkit';
import type { QueriesTreeState, TreeNode, ChildrenRow } from './types';
import { createAction, createReducer, createSelector } from '@reduxjs/toolkit';
import type { RootState } from '@Redux/store';

// AIDEV-NOTE: Minimal normalized structure for the tree
const initialState: QueriesTreeState = { nodes: {}, childrenByParent: {}, roots: ['queries'] };

export const setChildren = createAction<{ parentId: string; rows: ChildrenRow[] }>('queriesTree/setChildren');
export const upsertNode = createAction<TreeNode>('queriesTree/upsertNode');
export const addChild = createAction<{ parentId: string; node: TreeNode }>('queriesTree/addChild');
export const renameNode = createAction<{ id: string; name: string }>('queriesTree/renameNode');
export const moveNode = createAction<{ id: string; oldParentId: string; newParentId: string; index?: number }>('queriesTree/moveNode');

export default createReducer(initialState, (builder) => {
  builder
    .addCase(setChildren, (state, { payload }) => {
      const { parentId, rows } = payload;
      const ids: string[] = [];
      for (const r of rows) {
        state.nodes[r.id] = { ...r.data, id: r.id, parentId };
        ids.push(r.id);
      }
      state.childrenByParent[parentId] = ids;
    })
    .addCase(upsertNode, (state, { payload }) => {
      const cur = state.nodes[payload.id];
      state.nodes[payload.id] = { ...(cur || {}), ...payload };
    })
    .addCase(addChild, (state, { payload }) => {
      const { parentId, node } = payload;
      state.nodes[node.id] = { ...node, parentId };
      const arr = state.childrenByParent[parentId] || [];
      if (!arr.includes(node.id)) arr.push(node.id);
      state.childrenByParent[parentId] = arr;
    })
    .addCase(renameNode, (state, { payload }) => {
      const n = state.nodes[payload.id];
      if (n) n.name = payload.name;
    })
    .addCase(moveNode, (state, { payload }) => {
      const { id, oldParentId, newParentId, index } = payload;
      const oldArr = state.childrenByParent[oldParentId] || [];
      state.childrenByParent[oldParentId] = oldArr.filter((x) => x !== id);
      const newArr = state.childrenByParent[newParentId] || [];
      if (index !== undefined) newArr.splice(index, 0, id); else newArr.push(id);
      state.childrenByParent[newParentId] = newArr;
      if (state.nodes[id]) state.nodes[id].parentId = newParentId;
    });
});

// Selectors
export const selectChildrenWithData = createSelector.withTypes<RootState>()(
  [ (s: RootState, parentId: string) => parentId, (s: RootState) => (s as any).queriesTree as QueriesTreeState ],
  (parentId, tree) => {
    const ids = tree.childrenByParent[parentId] || [];
    return ids.map((id) => ({ id, data: tree.nodes[id] }));
  }
);

export const selectItem = createSelector.withTypes<RootState>()(
  [ (s: RootState, id: string) => id, (s: RootState) => (s as any).queriesTree as QueriesTreeState ],
  (id, tree) => tree.nodes[id]
);
```

- Wire into store: edit `src/redux/store.ts`
```ts
import queriesTreeReducer from './records/queriesTree';
// ...
const rootReducer = combineReducers({
  url: urlReducer,
  tabs: tabsReducer,
  dataQueryRecords: dataQueryRecordsReducer,
  errors: errorsReducer,
  queriesTree: queriesTreeReducer
});
```


2) Server action: fetch initial QUERIES children (SSR) and tag cache

- Update `src/app/opspace/[opspaceId]/queries/[dataQueryId]/_actions/queries.ts`
```ts
// inside file
import { updateTag } from 'next/cache';

const treeTag = (opspaceId: string, parentId: string) => `tree:children:${opspaceId}:${parentId}`;

export async function getQueriesTree() {
  const hdrs = await headers();
  const opspacePublicId = hdrs.get('x-opspace-id') || '';
  // Call backend/DB and return children (folder-first then name)
  const res = await fetch(`${process.env.PG_QUERY_CLIENT_SERVER_URL}/queries/tree`, {
    method: 'GET',
    headers: { 'accept': 'application/json' },
    next: { tags: [treeTag(opspacePublicId, 'queries')] }
  });
  const children = res.ok ? await res.json() : [];
  return {
    item: { id: 'queries', kind: 'folder', name: 'QUERIES' },
    children // [{ id, data: { id, kind, name } }]
  } as { item: { id: string; kind: 'folder'|'query'; name: string }; children: { id: string; data: { id: string; kind: 'folder'|'query'; name: string } }[] };
}

export async function saveDataQuery(unsavedDataQuery: DataQuery): Promise<{ success: boolean }> {
  // existing save logic...
  const result = await doSave(unsavedDataQuery);
  if (result) {
    const hdrs = await headers();
    const opspacePublicId = hdrs.get('x-opspace-id') || '';
    updateTag(treeTag(opspacePublicId, 'queries'));
    return { success: true };
  }
  return { success: false };
}
```


3) Server: fetch in layout and pass initial data

- Edit `src/app/opspace/[opspaceId]/queries/layout.tsx`
```tsx
// ...
import { getQueriesTree } from './[dataQueryId]/_actions/queries';

async function LayoutInner({ children, params }: { children: React.ReactNode; params: Promise<{ opspaceId: string }> }) {
  const { opspaceId } = await params;
  const initialQueriesTree = await getQueriesTree();
  return (
    <SQLRunnerProvider opspaceId={opspaceId}>
      <ChatProvider>
        <Titlebar />
        <PanelLayout
          left={<ChatPanel collapsed={false} side="left" />}
          right={<DirectoryPanel collapsed={false} side="right" initialQueriesTree={initialQueriesTree} />}
        >
          {children}
        </PanelLayout>
      </ChatProvider>
    </SQLRunnerProvider>
  );
}
```


4) DirectoryPanel: accept SSR data and seed client

- Edit `src/app/opspace/[opspaceId]/queries/[dataQueryId]/_components/DirectoryPanel/index.tsx`
```tsx
'use client';
import { useEffect } from 'react';
import { useReduxDispatch } from '@Redux/storeHooks';
import { setChildren } from '@Redux/records/queriesTree';

function DirectoryPanel({ collapsed, side = 'right', initialQueriesTree }: { collapsed: boolean; side?: 'left'|'right'; initialQueriesTree?: { item: { id: string; kind: 'folder'|'query'; name: string }; children: { id: string; data: { id: string; kind: 'folder'|'query'; name: string } }[] } }) {
  const dispatch = useReduxDispatch();
  useEffect(() => {
    if (initialQueriesTree?.children?.length) {
      dispatch(setChildren({ parentId: 'queries', rows: initialQueriesTree.children }));
    }
  }, [dispatch, initialQueriesTree]);
  // existing render stays the same
}
```


5) SectionTree dataLoader: cache-first via Redux

- Create `src/app/opspace/[opspaceId]/queries/[dataQueryId]/_components/DirectoryPanel/SectionTree/api/clientDataLoader.ts`
```ts
'use client';
import { store } from '@Redux/StoreProvider';
import { selectChildrenWithData, selectItem, setChildren, upsertNode } from '@Redux/records/queriesTree';
import { getItem, getChildrenWithData } from '../api/fsClient'; // keep existing endpoints for client fetch

export function makeClientDataLoader() {
  return {
    async getItem(id: string) {
      const s = store.getState();
      const cached = selectItem(s as any, id) as any;
      if (cached) return cached;
      const item = await getItem(id);
      store.dispatch(upsertNode(item as any));
      return item;
    },
    async getChildrenWithData(parentId: string) {
      const s = store.getState();
      const cached = selectChildrenWithData(s as any, parentId) as any[];
      if (cached && cached.length) return cached;
      const rows = await getChildrenWithData(parentId);
      store.dispatch(setChildren({ parentId, rows } as any));
      return rows;
    }
  };
}
```

- Edit `SectionTree/index.tsx` to use the client data loader
```ts
import { makeClientDataLoader } from './api/clientDataLoader';

const loader = makeClientDataLoader();
const tree = useTree<NodePayload>({
  // ...
  dataLoader: {
    getItem: (id) => loader.getItem(id),
    getChildrenWithData: (id) => loader.getChildrenWithData(id)
  },
  // ...
});
```


6) Save flow: optimistic add under QUERIES

- Edit `src/redux/operations/dataQuery.ts`
```ts
import { addChild } from '@Redux/records/queriesTree';

if (res?.success) {
  dispatch(markDataQuerySaved({ dataQueryId }));
  const name = record.current?.name || payload.name || 'untitled.sql';
  dispatch(addChild({ parentId: 'queries', node: { id: dataQueryId, kind: 'query', name } }));
}
```


7) Optional: rename/move integration

- After rename success: `dispatch(renameNode({ id, name }))` and refresh parent.
- After move success: `dispatch(moveNode({ id, oldParentId, newParentId }))` and refresh both parents.

Note

- Keep the JSON contracts minimal: `{ id, kind, name }` and children rows `{ id, data }`.
- Use Next.js 16 cache tags (`updateTag`) to keep SSR-cached initial children coherent after writes. Reference: [Next.js 16 – Improved Caching APIs](https://nextjs.org/blog/next-16#improved-caching-apis)

## Acceptance Criteria

- First load renders DirectoryPanel with user’s saved queries without any client fetch.
- Saving a new query adds it under QUERIES immediately (optimistic) and persists via server action.
- Tree loaders work from cache first, then server actions.
- JSON contracts limited to `id`, `kind`, `name`; tree behavior unchanged.

### To-dos

- [ ] Add server util returning { item, children } for 'queries'
- [ ] Fetch in queries/layout and pass initialChildren to client
- [ ] Implement client cache and dataLoader using cache-first
- [ ] Add Redux tree slice and selector for children-with-data
- [ ] Update save thunk to optimistically add child under 'queries'
- [ ] Wire rename/move actions to update Redux and refresh parents
- [ ] Confirm server depth guard aligns with UI rule